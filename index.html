<script>
// ...deja todo igual arriba...

  function splitFreeRects(freeRects, rect, pw, ph, kerf, cuts, nextOrder){
    // Sacamos el rectángulo usado
    let idx = freeRects.findIndex(r => r.x===rect.x && r.y===rect.y);
    if (idx===-1){ idx = 0; }
    const used = freeRects.splice(idx,1)[0];

    // REGISTRO DE CORTES (líneas de sierra):
    // Corte vertical a la derecha de la pieza (centro del kerf)
    const cutX = used.x + pw + (kerf>0 ? kerf/2 : 0);
    if (cutX <= used.x + used.w && kerf>0){
      cuts.push({
        x1: cutX, y1: used.y,
        x2: cutX, y2: used.y + ph,
        order: nextOrder(), type:'v'
      });
    }
    // Corte horizontal debajo de la pieza (centro del kerf)
    const cutY = used.y + ph + (kerf>0 ? kerf/2 : 0);
    if (cutY <= used.y + used.h && kerf>0){
      cuts.push({
        x1: used.x, y1: cutY,
        x2: used.x + used.w, y2: cutY,
        order: nextOrder(), type:'h'
      });
    }

    // Rectángulos libres resultantes
    const right = {
      x: used.x + pw + kerf,
      y: used.y,
      w: Math.max(0, used.w - pw - kerf),
      h: ph
    };
    const bottom = {
      x: used.x,
      y: used.y + ph + kerf,
      w: used.w,
      h: Math.max(0, used.h - ph - kerf)
    };

    if (right.w>0 && right.h>0) freeRects.push(right);
    if (bottom.w>0 && bottom.h>0) freeRects.push(bottom);
    mergeFreeRects(freeRects);
  }

// ...deja todo igual abajo...
</script>      <div class="row">
        <div><label>Cantidad
          <input type="number" id="cantidad" value="1" min="1" />
        </label></div>
        <div><label>Ancho (mm)
          <input type="number" id="ancho" min="1" required />
        </label></div>
        <div><label>Alto (mm)
          <input type="number" id="alto" min="1" required />
        </label></div>
      </div>
      <label>Nombre de la pieza (opcional)
        <input type="text" id="nombrePieza" placeholder="Ej: Puerta Cocina" />
      </label>
      <div class="inline" style="margin-top:.4rem">
        <span class="muted small">Cantos:</span>
        <label class="inline"><input type="checkbox" id="cantoIzq" /> Izq</label>
        <label class="inline"><input type="checkbox" id="cantoDer" /> Der</label>
        <label class="inline"><input type="checkbox" id="cantoSup" /> Sup</label>
        <label class="inline"><input type="checkbox" id="cantoInf" /> Inf</label>
      </div>
      <div class="row">
        <div>
          <label>Sobredimensión por canto (mm por lado)
            <input type="number" id="overCanto" value="0" min="0" step="0.5" />
          </label>
          <div class="hint">Se suma a la medida de corte por cada lado con canto.</div>
        </div>
        <div>
          <label>Prioridad (1=alta)
            <input type="number" id="prioridad" value="5" min="1" max="9" />
          </label>
        </div>
      </div>

      <div class="toolbar">
        <button id="btnAgregar">Agregar pieza</button>
        <button class="gray" id="btnLimpiarCampos">Limpiar campos</button>
      </div>
    </section>

    <!-- LISTA DE PIEZAS -->
    <section class="card">
      <div class="flex-between wrap">
        <h2>Lista de Piezas</h2>
        <div class="pilltabs">
          <button id="ordenTam" title="Ordenar por área desc">Orden área</button>
          <button id="ordenLado" title="Ordenar por mayor lado">Orden lado</button>
          <button id="ordenPri" title="Ordenar por prioridad asc">Orden prioridad</button>
        </div>
      </div>
      <table id="tablaPiezas">
        <thead>
          <tr>
            <th>#</th><th>Cant</th><th>Medidas</th><th>Nombre</th><th>Cantos</th><th>Over</th><th>Pri</th><th>Acción</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="toolbar">
        <button class="ghost" id="btnImportar">Importar JSON</button>
        <button class="ghost" id="btnExportar">Exportar JSON</button>
        <button class="ghost" id="btnCSV">Descargar CSV</button>
        <button class="danger" id="btnLimpiarTodo">Vaciar lista</button>
      </div>
    </section>

    <!-- OPTIMIZACIÓN / VISTA -->
    <section class="card" id="panelCortes">
      <div class="flex-between wrap">
        <h2>Optimización & Cortes</h2>
        <div class="toolbar">
          <button id="btnOptimizar">Optimizar corte</button>
          <button class="gray" id="btnVerCortes">Ver cortes</button>
        </div>
      </div>

      <div class="stat">
        <div><span>Total piezas</span><strong id="statPiezas">0</strong></div>
        <div><span>Placas usadas</span><strong id="statPlacas">0</strong></div>
        <div><span>Aprovechamiento</span><strong id="statAprov">0%</strong></div>
        <div><span>Desperdicio</span><strong id="statWaste">0%</strong></div>
      </div>

      <div class="canvas-wrap">
        <div class="flex-between wrap" style="margin:.2rem 0 .5rem">
          <div class="inline small">
            <span class="muted">Placa:</span>
            <div id="tabsPlacas" class="pilltabs"></div>
          </div>
          <div class="small mono" id="placaInfo"></div>
        </div>
        <canvas id="canvas" width="1300" height="900"></canvas>
      </div>
    </section>
  </div>

<script>
(() => {
  // ---------- Estado ----------
  const piezas = [];              // items base (como el usuario los carga)
  let piezasExpandidas = [];      // items "unitarios" contando cantidades
  let plan = [];                  // resultado por placas: {sheetW, sheetH, placed:[], scraps:[]}
  let currentSheetIndex = 0;
  let regenerating = false;

  // ---------- Helpers ----------
  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  function mm(n){ return Number.isFinite(+n) ? +n : 0 }
  function area(w,h){ return w*h }

  function cantosToStr(c){ return c && c.length ? c.join("") : "-" }

  function buildCutSize(p){
    // Aplica sobredimensión por cada lado que lleva canto
    const over = mm(p.overCanto||0);
    let addW = 0, addH = 0;
    if (p.cantos?.includes('Izq')) addW += over;
    if (p.cantos?.includes('Der')) addW += over;
    if (p.cantos?.includes('Sup')) addH += over;
    if (p.cantos?.includes('Inf')) addH += over;
    return {cw: p.ancho + addW, ch: p.alto + addH};
  }

  // ---------- UI: captura ----------
  const ui = {
    anchoPlaca: $('#placaAncho'),
    altoPlaca:  $('#placaAlto'),
    kerf:       $('#kerf'),
    margen:     $('#margen'),
    perimetral: $('#perimetral'),
    qtySheets:  $('#cantidadPlacas'),
    permitirRotar: $('#permitirRotar'),
    bloquearVeta:  $('#bloquearVeta'),

    cantidad: $('#cantidad'),
    ancho:    $('#ancho'),
    alto:     $('#alto'),
    nombre:   $('#nombrePieza'),
    cantoIzq: $('#cantoIzq'),
    cantoDer: $('#cantoDer'),
    cantoSup: $('#cantoSup'),
    cantoInf: $('#cantoInf'),
    overCanto: $('#overCanto'),
    prioridad: $('#prioridad'),

    tabla: $('#tablaPiezas tbody'),
    stats: {
      piezas: $('#statPiezas'),
      placas: $('#statPlacas'),
      aprov:  $('#statAprov'),
      waste:  $('#statWaste'),
    },
    canvas: $('#canvas'),
    tabsPlacas: $('#tabsPlacas'),
    placaInfo: $('#placaInfo'),
  };

  // ---------- Acciones básicas ----------
  function addPieza(){
    const cantidad = Math.max(1, mm(ui.cantidad.value));
    const ancho = mm(ui.ancho.value);
    const alto  = mm(ui.alto.value);
    const nombre = (ui.nombre.value||'').trim();
    const cantos = [];
    if (ui.cantoIzq.checked) cantos.push('Izq');
    if (ui.cantoDer.checked) cantos.push('Der');
    if (ui.cantoSup.checked) cantos.push('Sup');
    if (ui.cantoInf.checked) cantos.push('Inf');
    const overCanto = mm(ui.overCanto.value);
    const prioridad = mm(ui.prioridad.value)||5;

    if (!ancho || !alto || cantidad <= 0){
      alert('Faltan datos o cantidad inválida'); return;
    }
    piezas.push({ cantidad, ancho, alto, nombre: nombre||null, cantos, overCanto, prioridad });
    refreshTable();
    clearPieceInputs();
  }

  function clearPieceInputs(){
    ui.cantidad.value = 1;
    ui.ancho.value = '';
    ui.alto.value = '';
    ui.nombre.value = '';
    ui.cantoIzq.checked = ui.cantoDer.checked = ui.cantoSup.checked = ui.cantoInf.checked = false;
    // overCanto y prioridad se mantienen como último valor cargado (cómodo al cargar series)
  }

  function refreshTable(){
    ui.tabla.innerHTML = '';
    piezas.forEach((p, idx) => {
      const tr = document.createElement('tr');
      const cantos = cantosToStr(p.cantos.map(c=>c[0]));
      tr.innerHTML = `
        <td>${idx+1}</td>
        <td>${p.cantidad}</td>
        <td>${p.ancho} × ${p.alto}</td>
        <td>${p.nombre ? p.nombre : 'Pieza ' + (idx+1)}</td>
        <td><span class="tag">${cantos}</span></td>
        <td>${p.overCanto||0}</td>
        <td>${p.prioridad??5}</td>
        <td>
          <button class="gray" data-edit="${idx}">Editar</button>
          <button class="danger" data-del="${idx}">Borrar</button>
        </td>
      `;
      ui.tabla.appendChild(tr);
    });

    ui.stats.piezas.textContent = piezas.reduce((a,p)=>a+p.cantidad,0);
    attachRowActions();
  }

  function attachRowActions(){
    ui.tabla.querySelectorAll('button[data-del]').forEach(btn=>{
      btn.onclick = () => {
        const i = +btn.getAttribute('data-del');
        piezas.splice(i,1);
        refreshTable();
      }
    });
    ui.tabla.querySelectorAll('button[data-edit]').forEach(btn=>{
      btn.onclick = () => {
        const i = +btn.getAttribute('data-edit');
        const p = piezas[i];
        const nuevoNombre = prompt('Nombre (vacío para dejar igual):', p.nombre??'');
        if (nuevoNombre!==null) p.nombre = nuevoNombre.trim()||null;
        const nuevoAncho = prompt('Ancho (mm):', p.ancho);
        if (nuevoAncho!==null && mm(nuevoAncho)>0) p.ancho = mm(nuevoAncho);
        const nuevoAlto = prompt('Alto (mm):', p.alto);
        if (nuevoAlto!==null && mm(nuevoAlto)>0) p.alto = mm(nuevoAlto);
        const nuevaCant = prompt('Cantidad:', p.cantidad);
        if (nuevaCant!==null && mm(nuevaCant)>0) p.cantidad = mm(nuevaCant);
        const nuevoOver = prompt('Sobredimensión por canto (mm por lado):', p.overCanto||0);
        if (nuevoOver!==null && mm(nuevoOver)>=0) p.overCanto = mm(nuevoOver);
        const nuevaPri = prompt('Prioridad (1=alta):', p.prioridad??5);
        if (nuevaPri!==null && mm(nuevaPri)>=1) p.prioridad = mm(nuevaPri);
        refreshTable();
      }
    });
  }

  // ---------- Import / Export ----------
  $('#btnExportar').onclick = () => {
    const data = JSON.stringify(piezas, null, 2);
    downloadFile('piezas.json', data, 'application/json');
  };
  $('#btnImportar').onclick = async () => {
    const text = prompt('Pega aquí el JSON de piezas:');
    if (!text) return;
    try{
      const arr = JSON.parse(text);
      if (!Array.isArray(arr)) throw new Error('Formato inválido');
      piezas.splice(0,piezas.length, ...arr);
      refreshTable();
    }catch(e){
      alert('JSON inválido: '+e.message);
    }
  };
  $('#btnCSV').onclick = () => {
    if (!piezas.length){ alert('No hay piezas'); return; }
    const rows = [['Cant','Ancho','Alto','Nombre','Cantos','OverCanto','Prioridad']];
    piezas.forEach(p=>{
      rows.push([p.cantidad,p.ancho,p.alto,(p.nombre||''), (p.cantos||[]).join('-'), (p.overCanto||0), (p.prioridad??5)]);
    });
    const csv = rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
    downloadFile('piezas.csv', csv, 'text/csv');
  };
  function downloadFile(name, content, type){
    const blob = new Blob([content], {type});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name; a.click();
    URL.revokeObjectURL(a.href);
  }

  // ---------- Orden ----------
  $('#ordenTam').onclick = () => {
    piezas.sort((a,b)=> (b.ancho*b.alto) - (a.ancho*a.alto)); refreshTable();
  };
  $('#ordenLado').onclick = () => {
    const maxSide = p=> Math.max(p.ancho,p.alto);
    piezas.sort((a,b)=> maxSide(b)-maxSide(a)); refreshTable();
  };
  $('#ordenPri').onclick = () => {
    piezas.sort((a,b)=> (a.prioridad??5)-(b.prioridad??5)); refreshTable();
  };

  // ---------- Expansión de cantidades ----------
  function expandQuantities(){
    piezasExpandidas = [];
    piezas.forEach(p=>{
      for (let i=0;i<p.cantidad;i++){
        const {cw, ch} = buildCutSize(p);
        piezasExpandidas.push({
          base:p,
          w:cw, h:ch,
          canRotate: $('#permitirRotar').checked && !$('#bloquearVeta').checked,
          name: p.nombre||`Pieza`,
          cantos: p.cantos||[],
          prioridad: p.prioridad??5,
        });
      }
    });
    // Orden por prioridad, área desc, mayor lado
    piezasExpandidas.sort((a,b)=>{
      if ((a.prioridad??5)!==(b.prioridad??5)) return (a.prioridad??5)-(b.prioridad??5);
      const ad= b.w*b.h - a.w*a.h;
      if (ad!==0) return ad;
      return Math.max(b.w,b.h) - Math.max(a.w,a.h);
    });
  }

  // ---------- Algoritmo: Guillotine con lista de rectángulos libres ----------
  function optimize(){
    const sheetW = mm(ui.anchoPlaca.value);
    const sheetH = mm(ui.altoPlaca.value);
    const kerf   = mm(ui.kerf.value);
    const margin = mm(ui.margen.value);
    const trim   = mm(ui.perimetral.value);
    const qty    = Math.max(1, mm(ui.qtySheets.value));

    if (!sheetW || !sheetH){ alert('Dimensiones de placa inválidas'); return; }
    if (!piezas.length){ alert('Agrega piezas primero'); return; }

    expandQuantities();

    plan = [];
    let remaining = [...piezasExpandidas];

    const usableW = sheetW - 2*margin - 2*trim;
    const usableH = sheetH - 2*margin - 2*trim;
    if (usableW<=0 || usableH<=0){
      alert('Los márgenes/perimetral son muy grandes para la placa'); return;
    }

    for (let s=0; s<qty && remaining.length>0; s++){
      const placed = [];
      const scraps = [];
      // Rectángulos libres inicial: una sola celda usable
      let freeRects = [{x: margin+trim, y: margin+trim, w: usableW, h: usableH}];

      // Para cada pieza
      remaining = remaining.filter(piece=>{
        const fit = findPlaceForPiece(piece, freeRects, kerf);
        if (!fit) return true; // queda sin colocar
        const {rect, rotated} = fit;
        placed.push({
          x: rect.x, y: rect.y, w: piece.w, h: piece.h, rotated,
          name: piece.name, cantos: piece.cantos
        });
        // Split del rectángulo usado (guillotina): genera derecha y abajo
        splitFreeRects(freeRects, rect, piece.w, piece.h, kerf);
        return false;
      });

      // Lo que queda como libres se considera "scrap"
      scraps.push(...freeRects);

      plan.push({sheetW, sheetH, placed, scraps});
    }

    // stats
    updateStats();
    buildSheetTabs();
    drawSheet(currentSheetIndex=0);
  }

  // Buscar primer rectángulo donde entre (con o sin rotar)
  function findPlaceForPiece(piece, freeRects, kerf){
    const allowRotate = $('#permitirRotar').checked && !$('#bloquearVeta').checked;
    for (let i=0;i<freeRects.length;i++){
      const fr = freeRects[i];
      // Probamos sin rotar
      if (piece.w <= fr.w && piece.h <= fr.h){
        return {rect:{x:fr.x, y:fr.y}, rotated:false};
      }
      // Con rotación (si se permite)
      if (allowRotate && (piece.h <= fr.w && piece.w <= fr.h)){
        return {rect:{x:fr.x, y:fr.y}, rotated:true};
      }
    }
    return null;
  }

  // Divide el rectángulo libre donde colocamos la pieza, agregando kerf entre cortes
  function splitFreeRects(freeRects, rect, pw, ph, kerf){
    // Pop el primero que coincide en xy (el que usamos)
    let idx = freeRects.findIndex(r => r.x===rect.x && r.y===rect.y);
    if (idx===-1){ idx = 0; }
    const used = freeRects.splice(idx,1)[0];

    // Derecha del corte
    const right = {
      x: used.x + pw + kerf,
      y: used.y,
      w: Math.max(0, used.w - pw - kerf),
      h: ph
    };
    // Abajo del corte
    const bottom = {
      x: used.x,
      y: used.y + ph + kerf,
      w: used.w,
      h: Math.max(0, used.h - ph - kerf)
    };
    // Rectángulo "abajo derecha" ya queda implícito con sucesivos splits (est
